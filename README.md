# 华为CodeCraft2019

<!-- TOC -->

- [华为CodeCraft2019](#华为codecraft2019)
    - [模型建立](#模型建立)
        - [1、GetFloydMap](#1getfloydmap)
        - [2、Astar](#2astar)
- [常用路径规划算法](#常用路径规划算法)
    - [1、Dijkstra算法](#1dijkstra算法)
    - [2、A*算法](#2a算法)
        - [启发函数](#启发函数)
    - [3、Floyd动态路径规划算法](#3floyd动态路径规划算法)
- [比赛规则简单介绍](#比赛规则简单介绍)
    - [1. 背景信息](#1-背景信息)
    - [2. 题目定义](#2-题目定义)
    - [3. 系统假定](#3-系统假定)
    - [4. 约束条件](#4-约束条件)
    - [5. 题目输入](#5-题目输入)

<!-- /TOC -->

 ## 前言
这次的华为挑战赛，号称这个比赛最难的一次题目，车辆调度规则的确是挺复杂的，但是也有很大的漏洞，即使不写出调度器，只进行简单的最短路径规划，然后根据地图，路口，车辆的各种数据特征进行分析，在只针对固定地图的情况下进行参数调试，也可以取得比较理想的成绩，自己一开始也是这样做的，而且测试赛阶段成绩还可以，后来觉得这种投机取巧的方法总感觉是不可靠的，也许能混进复赛，但是绝对不会进入前几，获得华为的深圳决赛资格，享受华为费用全包的土豪生活的(1_1)，于是在正式比赛前的一周，决定撸起来了调度器，辛辛苦苦写了一千多行的代码，进行路径的实时规划，然而，然而............
<div  align="center">
<img src="https://i.loli.net/2019/04/01/5ca1737180f07.jpg" width="300" hegiht="300"/>


事实证明，没事不要搞什么乱起八糟的算法，好好调参不就行了吗，真是应验了宣讲会学长说的：“不要搞那些复杂的算法，往往简单的算法能取得很好的效果”。正式比赛的时候，本地运行没什么问题，已上传代码以后各种"Program runs failed",折腾了一天都不知道啥子问题，最后只能把原来的代码搞了上去，一看这成绩我就知道凉了，单图的成绩是别人双图的成绩加起来还多.....

<div  align="center">
<img src="https://i.loli.net/2019/04/01/5ca17476dcf1b.jpg" width="300" hegiht="300"/>

 此次挑战赛的题目是关于智能交通的，一开始只看题目的简单介绍还是感觉不是特别复杂的，但是在比赛任务书的详细介绍里面，则是拥有了很多的限制条件，尤其如何处理道路死锁那一块，一直是整个比赛当中影响整个比赛成绩的关键，自己是在车辆调度过程当中，判断下一条道路状态，如果道路无法进入，就重新寻路，或者延迟这辆车的发车时间，但是效果不是特别的理想，单图2100左右(<font size = 2>*虽然使用自己的判断器试的1_1，测试赛上传没问题，正式赛就不行了......真是一个令人伤心的故事，也怪自己没有做好代码备份*</font>）。
 
比赛结束了，想把自己用到的算法总结一下，这次比赛路径规划算法自己用的Astar,不得不说这个算法的确是很快，看到很多人在群里面问Astar算法怎么给这次比赛地图建模，以及H值怎么算，在此分享出来自己的思路，供需要的“有缘人”提取，如果你觉得还可以，There have  a star button no the top 。

## 模型建立
正常情况下Astart算法的模型建立，每一个Node都有相应的坐标，这样建立的模型使用曼哈顿距离很容易算出来G值与H值，但是这次比赛给的数据的节点分布并不确定每个点的具体坐标，也就导模型建立不正确的话H值无法计算，

但是回归Astar算法原理，当我们给定一个起点Node以后(也就是车辆发车路口)，我们可以遍历这个路口所有可以始离这个路口的道路(单双道路判别)，将他们所有可以到达的Cross加入到OpenList当中，然后比较它们的F值，找出来最小的那个，保存相应的Node到CloseList，如此进行下去，最终的CloseList当中便保存了我们需要的路径信息。

但是以上的模型当中，H值与G值是无法很好计算的，后来又了解到Floyd算法可以很好的算出地图当中所有节点之间的最短距离，这不正是我们需要的吗，程序一开始就可以读入所有的Cross与Road数据，计算出整个地图当中所有的点之间的距离，保存在一个字典当中，这样我们在计算G值与H值的时候，只需要输入相应的CrossId，便可以立马得到。两者的结合使程序既能找到最短路径，又加快了路径规划速度。相应伪代码：
### 1、GetFloydMap
```python
#首先得到初始连接矩阵，一个节点可以到另一个节点去，相应矩阵位置赋值为Road.length,否则np.inf
for Roads in NowCross.road:
	for roadId in Roads:
		NextCross = RoadDic(roadId)
		if NowCross can reach the NextCross:
			map[NowCrossId][NextCrossId] = road.length
		else:
			map[NowCrossId][NextCrossId] = np.inf
#根据floyd算法得出所有节点之间的距离，updateMap

for k in crossData:
   for i in crossData:
       for j in crossData:
           if map[i][j] > map[i][k] + map[k][j]:
              map[i][j] = map[i][k] + map[k][j]
return map
```
### 2、Astar
```python
#初始化开闭列表，初始化节点
openList = []
# 关闭表
closeList = []
startId = car.start
endId = car.to
# 1.将起点放入openList
startNode = MyRoute.Node(startId, endId)
openList.append(startNode)
#遍历寻路
while True:
     # 找到F值最小的点
     minNode = self.getMinNode()
     nextId = minNode.Id
     # 把这个点加入closeList中，并且在openList中删除它
     closeList.append(minNode)
     openList.remove(minNode)
     # 寻找与这个路口相连接的路口
     for Roads in NowCross.road:
		 for roadId in Roads:
			 NextCross = RoadDic(roadId)
			 if NowCross can reach the NextCross:
			    #将当前节点加入openList
    # 判断是否终止
    judgeNode = self.endIdInCloseList(endId)
    # 如果终点在关闭表中，就返回结果
    if judgeNode: 
    return path
```


# 常用路径规划算法

## 1、Dijkstra算法
参考来源:[Dijkstra](https://www.jianshu.com/p/a3951ce7574d)

Dijkstra算法是由计算机科学家[Edsger W. Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra)在1956年提出的。

考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。

在Dijkstra算法中，需要计算每一个节点距离起点的总移动代价。同时，还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。

在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。

Dijkstra算法保证能找到一条从初始点到目标点的最短路径，只要所有的边都有一个非负的代价值。

下面对比了不考虑节点移动代价差异的广度优先搜索与考虑移动代价的Dijkstra算法的运算结果：
![Dijkstra](https://upload-images.jianshu.io/upload_images/2509688-511df02960b9f93e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)
  
## 2、A*算法
A*算法通过下面这个函数来计算每个节点的优先级。
$f(n) =g(n)+h(n)$
其中：
-   f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。
-   g(n) 是节点n距离起点的代价。
-   h(n)是节点n距离终点的预计代价，这也就是A*算法的**启发函数**。

A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。

另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为`open_set`和`close_set`。

**A*算法与Dijkstra算法速度比较**

<div  align="center">
<img src="https://upload-images.jianshu.io/upload_images/12119754-0479d0d83f9cb9b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/479/format/webp" width="600" hegiht="500"/>

### 启发函数
启发函数会影响A*算法的行为。
-   在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。
-   如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
-   如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
-   如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。
-   在另外一个极端情况下，如果h()n相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。

由上面这些信息我们可以知道，通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是A*算法比较灵活的地方。

  对于网格形式的图，有以下这些启发函数可以使用：

-   如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。
-   如果图形中允许朝八个方向移动，则可以使用对角距离。
-   如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。

A*算法讲解很不错的一篇文章：[A*](https://blog.csdn.net/zhulichen/article/details/78786493)

## 3、Floyd动态路径规划算法
Floyd算法原理：[Floyd](https://www.cnblogs.com/GumpYan/p/5540549.html)
Floyd算法的核心代码只有五行，十分的简洁：
```python
  for i in range(allNode):
    for j in range(allNode):
        for k in range(allNode):
            if(D[i,j] > D[i,k]+D[j,k]):         #两个顶点直接较小的间接路径替换较大的直接路径
                P[i,j] = P[j,k]                 #记录新路径的前驱
```
通过Floyd算法可以求取出地图当中任意两个节点之间的最短距离，但是计算量很大，每次增加节点个数，程序所需的运行时间也是飞速的上升，但是只用其更新初始地图状态每两个节点之间的距离（只更新一次，不求取每两个节点间的路径），作为Astar算法H与G值的输入，路径规划算法交给Astar来处理，速度还是非常快的。



# 比赛规则简单介绍

## 1. 背景信息  
道路交通是城市的核心要素之一。随着社会经济的发展，中国城市的车辆保有量已经越来越多，大都市慢慢变成了“堵”市。如何在出行时避免拥堵，是每一个人的目标。
日常生活中，很多拥堵是由于车辆行驶路线规划失误，大批车辆集中选择主干道行驶导致通行效率下降。

如果车辆都由调度中心统一规划调度路线，拥堵问题将得到大大缓解甚至彻底解决。
实际上这一技术已经在工业领域如矿山车辆、无人货仓等得到广泛应用。

但道路上的私家车辆尚无法进行统一规划，未来，自动驾驶和物联网技术的结合，使得彻底解决这一难题出现了曙光。

请同学们提前出任“首席城市交通规划官”，为未来城市规划好每一辆车的行驶路线。
## 2. 题目定义  
在模拟的道路图上为每一辆车规划行驶路线，系统会自动根据规划路线运行。
在路线合法的前提下，最终所有车辆按照规划的路线到达目的地。

## 3. 系统假定  
**路口完全立交**：假定在每一个路口交汇的所有道路都可以完全互连，且车辆通过路口时不考虑在路口的通行时间。
**无限神奇车库**：我们认为，系统中的每个地点都有一个无限容量的“神奇车库”。车辆在未到既定出发时间前，或者到达目的后，就停放在“神奇车库”中，完全不影响其他车辆通过。但车辆一旦出发，在行驶过程中则不允许进入车库空间。
##  4. 约束条件  
 **不允许超车变道**：即车辆一旦进入某条车道，就必须在此车道内从道路起点驶向道路终点，中途不允许变道，即使前车速度缓慢，也不允许超车。
 
 **排队先到先行**：在一条道路前排队等待的所有车辆，按照到达时间先后进入道路。若多辆车在同一时间到达，按如下规则进入下一道路：

1. 同一道路牌车道号小（车道的编号）的车辆优先于车道号大的车辆

<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca0719b1a196.png" width="300" hegiht="300"/>

2. 按现实交通规则，直行车辆有优先通行权，直行车辆优先于转弯车辆

<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca0719b1a196.png" width="300" hegiht="300"/>

4. 处于左转进入道路的车辆优先于右转进入道路的车辆
<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca0732bee1e6.png" width="300" hegiht="300"/>

 **车道固定进入**：车辆在进入一段道路时按照车道编号从小到大的优先级选择可以进入的车道驶入，与前车的行驶速度无关。即就是：车辆优先按车道编号由小到大依次进入，除非车道号小的车道没有空位可进入。
<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca073f03f455.png" width="400" hegiht="300"/>

**如下Figure 5**：车道行驶规则举例所示，左侧道路车辆经一定时间行驶达到右侧道路车辆状态。

<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca073fd5add7.png" width="400" hegiht="400"/>

## 5. 题目输入  

每一个测试用例都分为三部分：

**道路**
道路数据文件“road.txt”文件。
 每一行数据为一条道路。
每条道路数据表示为：**(道路id，道路长度，最高限速，车道数目，起始点id，终点id，是否双向)**格式的向量。例如(502, 10, 6, 5, 2, 3, 1)的向量表示编号为502的道路，连接路口2和路口3的长度为10，限速6的双向5车道路段; (502, 10, 6, 5, 2, 3, 0)的向量表示编号为502的道路，连接路口2和路口3的长度为10，限速6的单向5车道路段。
起始点id：路口id（下文中有描述）
终止点id：路口id（下文中有描述）
是否双向：1：双向；0：单向
不管是双向道路还是单向道路，一条道路数据只会有一行数据表示，不会因为双向而多出来一行道路的数据表示。
“#”开始的数据行为说明性文字，可以理解成为注释。如“#(id,length,speed,channel,form,to,isDuplex)”。
对于多车道的道路，相对于行驶方向，车道编号从左至右依次增大。

<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca073fd04f42.png" width="400" hegiht="300"/>

**车辆**
车辆数据文件“car.txt”。
 每一行数据为一车辆。
 每辆车数据表示为：**(车辆id，始发地、目的地、最高速度、出发时间)**格式的向量。例如(1001,1,16,6,1)的向量表示一辆编号是1001最高速度为6的车辆要在时间点1从路口1到达路口16。
始发地：路口id（下文中有描述）
目的地：路口id（下文中有描述）
“#”开始的数据行为说明性文字，可以理解成为注释。如“#(id,始发地,目的地,最高速度,出发时间)”。
**路口**
路口数据文件“cross.txt”。
每一行数据为一个路口。
每个路口数据表示为：(路口id,道路id,道路id,道路id,道路id)格式的向量。例如(6, 504, 514, 505, 518)表示504，514，505，518这四条路段交汇的编号为6的路口。
路口信息数据向量中的道路id，以路口为中心，其所连接的道路id按顺时针方向编排。比如向量(100,21,30,9,55)和(100,21,30,-1,55)分别表示如下：

<div  align="center">
<img src="https://i.loli.net/2019/03/31/5ca073fd5664e.png" width="600" hegiht="500"/>


l “#”开始的数据行为说明性文字，可以理解成为注释。如：“#(结点id,道路id,道路id,道路id,道路id)”。

**数据样例：**

l  **Car.txt**
```
#(id,始发地,目的地,最高速度,出发时间)
(1001,1,16,6,1)
```
l  **Road.txt**
```
#(道路id，道路长度，最高限速，车道数目，起始点id，终点id，是否双向)
(501, 10, 6, 5, 1, 2, 1)
```
l  **Cross.txt**
```
#(结点id,道路id,道路id,道路id,道路id)
(1, 501, 513, -1, -1)
```


